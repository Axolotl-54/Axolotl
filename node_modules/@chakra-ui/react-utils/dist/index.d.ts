import { Merge, EventKeys } from '@chakra-ui/utils';
import * as react from 'react';

declare type ReactRef<T> = React.Ref<T> | React.RefObject<T> | React.MutableRefObject<T>;
/**
 * Assigns a value to a ref function or object
 *
 * @param ref the ref to assign to
 * @param value the value
 */
declare function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T): void;
/**
 * Combine multiple React refs into a single ref function.
 * This is used mostly when you need to allow consumers forward refs to
 * internal components
 *
 * @param refs refs to assign to value to
 */
declare function mergeRefs<T>(...refs: (ReactRef<T> | undefined)[]): (node: T | null) => void;

interface CreateContextOptions {
    /**
     * If `true`, React will throw if context is `null` or `undefined`
     * In some cases, you might want to support nested context, so you can set it to `false`
     */
    strict?: boolean;
    /**
     * Error message to throw if the context is `undefined`
     */
    errorMessage?: string;
    /**
     * The display name of the context
     */
    name?: string;
}
declare type CreateContextReturn<T> = [
    React.Provider<T>,
    () => T,
    React.Context<T>
];
/**
 * Creates a named context, provider, and hook.
 *
 * @param options create context options
 */
declare function createContext<ContextType>(options?: CreateContextOptions): CreateContextReturn<ContextType>;

declare type MaybeRenderProp<P> = React.ReactNode | ((props: P) => React.ReactNode);
declare type WithoutStyleAttr<T> = Omit<T, "color" | "width" | "height">;
declare type HTMLProps<T = any> = WithoutStyleAttr<React.HTMLAttributes<T>> & React.RefAttributes<T>;
declare type PropGetter<T extends HTMLElement = any, P = {}> = (props?: Merge<HTMLProps<T>, P>, ref?: React.Ref<any> | React.RefObject<any>) => Merge<HTMLProps<T>, P>;
declare type PropGetterV2<T extends React.ElementType, P = {}> = (props?: WithoutStyleAttr<React.ComponentPropsWithoutRef<T>> & P, ref?: React.Ref<any> | React.RefObject<any>) => WithoutStyleAttr<React.ComponentPropsWithRef<T>>;
declare type EventKeyMap = Partial<Record<EventKeys, React.KeyboardEventHandler>>;

/**
 * Gets only the valid children of a component,
 * and ignores any nullish or falsy child.
 *
 * @param children the children
 */
declare function getValidChildren(children: React.ReactNode): react.ReactElement<any, string | react.JSXElementConstructor<any>>[];

export { CreateContextOptions, CreateContextReturn, EventKeyMap, HTMLProps, MaybeRenderProp, PropGetter, PropGetterV2, ReactRef, assignRef, createContext, getValidChildren, mergeRefs };
