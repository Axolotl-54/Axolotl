import * as _chakra_ui_system from '@chakra-ui/system';
import { ThemingProps, SystemProps, HTMLChakraProps } from '@chakra-ui/system';
import * as _chakra_ui_react_types from '@chakra-ui/react-types';
import { PropGetter, InputDOMAttributes } from '@chakra-ui/react-types';
import * as react from 'react';

/**
 * @todo use the `useClickable` hook here
 * to manage the isFocusable & isDisabled props
 */
interface UseRadioProps {
    /**
     * id assigned to input
     */
    id?: string;
    /**
     * The name of the input field in a radio
     * (Useful for form submission).
     */
    name?: string;
    /**
     * The value to be used in the radio button.
     * This is the value that will be returned on form submission.
     */
    value?: string | number;
    /**
     * If `true`, the radio will be checked.
     * You'll need to pass `onChange` to update its value (since it is now controlled)
     */
    isChecked?: boolean;
    /**
     * If `true`, the radio will be initially checked.
     */
    defaultChecked?: boolean;
    /**
     * If `true`, the radio will be disabled
     */
    isDisabled?: boolean;
    /**
     * If `true` and `isDisabled` is true, the radio will remain
     * focusable but not interactive.
     */
    isFocusable?: boolean;
    /**
     * If `true`, the radio will be read-only
     */
    isReadOnly?: boolean;
    /**
     * If `true`, the radio button will be invalid. This also sets `aria-invalid` to `true`.
     */
    isInvalid?: boolean;
    /**
     * If `true`, the radio button will be required. This also sets `aria-required` to `true`.
     */
    isRequired?: boolean;
    /**
     * Function called when checked state of the `input` changes
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;
    /**
     * @internal
     */
    "data-radiogroup"?: any;
    /**
     * Refers to the `id` of the element that labels the radio element.
     */
    "aria-describedby"?: string;
}
interface RadioState {
    isInvalid: boolean | undefined;
    isFocused: boolean;
    isChecked: boolean;
    isActive: boolean;
    isHovered: boolean;
    isDisabled: boolean | undefined;
    isReadOnly: boolean | undefined;
    isRequired: boolean | undefined;
}
/**
 * `useRadio` is a custom hook used to provide radio functionality, as well as state and focus management to custom radio components when using it.
 *
 * @see Docs https://chakra-ui.com/docs/hooks/use-radio
 */
declare function useRadio(props?: UseRadioProps): {
    state: RadioState;
    getCheckboxProps: PropGetter<Record<string, unknown>, _chakra_ui_react_types.DOMAttributes<_chakra_ui_react_types.DOMElement>>;
    getInputProps: PropGetter<InputDOMAttributes, InputDOMAttributes>;
    getLabelProps: PropGetter<Record<string, unknown>, _chakra_ui_react_types.DOMAttributes<_chakra_ui_react_types.DOMElement>>;
    getRootProps: PropGetter<Record<string, unknown>, _chakra_ui_react_types.DOMAttributes<_chakra_ui_react_types.DOMElement>>;
    htmlProps: {};
};
declare type UseRadioReturn = ReturnType<typeof useRadio>;

declare type Omitted$1 = "onChange" | "defaultChecked" | "checked";
interface BaseControlProps extends Omit<HTMLChakraProps<"div">, Omitted$1> {
}
interface RadioProps extends UseRadioProps, ThemingProps<"Radio">, BaseControlProps {
    /**
     * The spacing between the checkbox and its label text
     * @default 0.5rem
     * @type SystemProps["marginLeft"]
     */
    spacing?: SystemProps["marginLeft"];
    /**
     * Additional props to be forwarded to the `input` element
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
}
/**
 * Radio component is used in forms when a user needs to select a single value from
 * several options.
 *
 * @see Docs https://chakra-ui.com/radio
 */
declare const Radio: _chakra_ui_system.ComponentWithAs<"input", RadioProps>;

declare type EventOrValue = React.ChangeEvent<HTMLInputElement> | string | number;
interface UseRadioGroupProps {
    /**
     * The value of the radio to be `checked`
     * (in controlled mode)
     */
    value?: string | number;
    /**
     * The value of the radio to be `checked`
     * initially (in uncontrolled mode)
     */
    defaultValue?: string | number;
    /**
     * Function called once a radio is checked
     * @param nextValue the value of the checked radio
     */
    onChange?(nextValue: string): void;
    /**
     * If `true`, all wrapped radio inputs will be disabled
     */
    isDisabled?: boolean;
    /**
     * If `true` and `isDisabled` is true, all wrapped radio inputs will remain
     * focusable but not interactive.
     */
    isFocusable?: boolean;
    /**
     * The `name` attribute forwarded to each `radio` element
     */
    name?: string;
    /**
     * If `true`, input elements will receive
     * `checked` attribute instead of `isChecked`.
     *
     * This assumes, you're using native radio inputs
     */
    isNative?: boolean;
}
/**
 * `useRadioGroup` is a custom hook that provides all the state management logic for a group of radios.
 *
 * @see Docs https://chakra-ui.com/docs/hooks/use-radio-group
 */
declare function useRadioGroup(props?: UseRadioGroupProps): {
    getRootProps: PropGetter<Record<string, unknown>, _chakra_ui_react_types.DOMAttributes<_chakra_ui_react_types.DOMElement>>;
    getRadioProps: PropGetter<_chakra_ui_react_types.InputDOMProps & react.AriaAttributes & react.DOMAttributes<HTMLInputElement> & _chakra_ui_react_types.DataAttributes & {
        id?: string | undefined;
        role?: react.AriaRole | undefined;
        tabIndex?: number | undefined;
        style?: react.CSSProperties | undefined;
    } & {
        isChecked?: boolean | undefined;
    }, InputDOMAttributes>;
    name: string;
    ref: react.MutableRefObject<any>;
    focus: () => void;
    setValue: react.Dispatch<react.SetStateAction<string | number>>;
    value: string | number;
    onChange: (eventOrValue: EventOrValue) => void;
    isDisabled: boolean | undefined;
    isFocusable: boolean | undefined;
    htmlProps: {};
};
declare type UseRadioGroupReturn = ReturnType<typeof useRadioGroup>;

interface RadioGroupContext extends Pick<UseRadioGroupReturn, "onChange" | "value" | "name" | "isDisabled" | "isFocusable">, Omit<ThemingProps<"Radio">, "orientation"> {
}
declare const useRadioGroupContext: () => RadioGroupContext;

declare type Omitted = "onChange" | "value" | "defaultValue" | "defaultChecked" | "children";
interface RadioGroupProps extends UseRadioGroupProps, Omit<HTMLChakraProps<"div">, Omitted>, Omit<ThemingProps<"Radio">, "orientation"> {
    children: React.ReactNode;
}
/**
 * Used for multiple radios which are bound in one group,
 * and it indicates which option is selected.
 *
 * @see Docs https://chakra-ui.com/radio
 */
declare const RadioGroup: _chakra_ui_system.ComponentWithAs<"div", RadioGroupProps>;

export { Radio, RadioGroup, RadioGroupContext, RadioGroupProps, RadioProps, RadioState, UseRadioGroupProps, UseRadioGroupReturn, UseRadioProps, UseRadioReturn, useRadio, useRadioGroup, useRadioGroupContext };
