import * as react from 'react';
import { RefObject, useLayoutEffect, useEffect } from 'react';
import { BoxModel, PointerEventInfo, EventListenerWithPointInfo, FocusableElement, PanEventHandler } from '@chakra-ui/utils';

declare type UseAnimationStateProps = {
    isOpen: boolean;
    ref: React.RefObject<HTMLElement>;
};
declare function useAnimationState(props: UseAnimationStateProps): {
    present: boolean;
    onComplete(): void;
};

declare type InitialState = boolean | (() => boolean);
/**
 * React hook to manage boolean (on - off) states
 *
 * @param initialState the initial boolean state value
 *
 * @see Docs https://chakra-ui.com/docs/hooks/use-boolean
 */
declare function useBoolean(initialState?: InitialState): readonly [boolean, {
    on: () => void;
    off: () => void;
    toggle: () => void;
}];

/**
 * React hook to persist any value between renders,
 * but keeps it up-to-date if it changes.
 *
 * @param fn the function to persist
 * @param deps the function dependency list
 */
declare function useCallbackRef<T extends (...args: any[]) => any>(fn: T | undefined, deps?: React.DependencyList): T;

interface UseClipboardOptions {
    /**
     * timeout delay (in ms) to switch back to initial state once copied.
     */
    timeout?: number;
    /**
     * Set the desired MIME type
     */
    format?: string;
}
/**
 * React hook to copy content to clipboard
 *
 * @param initialValue the text or value to copy
 * @param {Number} [optionsOrTimeout=1500] optionsOrTimeout - delay (in ms) to switch back to initial state once copied.
 * @param {Object} optionsOrTimeout
 * @param {string} optionsOrTimeout.format - set the desired MIME type
 * @param {number} optionsOrTimeout.timeout - delay (in ms) to switch back to initial state once copied.
 *
 * @see Docs https://chakra-ui.com/docs/hooks/use-clipboard
 */
declare function useClipboard(initialValue: string, optionsOrTimeout?: number | UseClipboardOptions): {
    value: string;
    setValue: react.Dispatch<react.SetStateAction<string>>;
    onCopy: () => void;
    hasCopied: boolean;
};

declare type InitFn<T> = () => T;
/**
 * Creates a constant value over the lifecycle of a component.
 *
 * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer
 * a guarantee that it won't re-run for performance reasons later on. By using `useConst`
 * you can ensure that initializers don't execute twice or more.
 */
declare function useConst<T extends any>(init: T | InitFn<T>): T;

declare function useControllableProp<T>(prop: T | undefined, state: T): readonly [boolean, T];
interface UseControllableStateProps<T> {
    /**
     * The value to used in controlled mode
     */
    value?: T;
    /**
     * The initial value to be used, in uncontrolled mode
     */
    defaultValue?: T | (() => T);
    /**
     * The callback fired when the value changes
     */
    onChange?: (value: T) => void;
    /**
     * The function that determines if the state should be updated
     */
    shouldUpdate?: (prev: T, next: T) => boolean;
}
/**
 * React hook for using controlling component state.
 * @param props
 */
declare function useControllableState<T>(props: UseControllableStateProps<T>): [T, react.Dispatch<react.SetStateAction<T>>];

/**
 * React hook to measure a component's dimensions
 *
 * @param ref ref of the component to measure
 * @param observe if `true`, resize and scroll observers will be turned on
 *
 * @deprecated use the `useSize` hook instead
 *
 * ```jsx
 * import { useSize } from "@chakra-ui/react-use-size"
 * ```
 */
declare function useDimensions(ref: React.RefObject<HTMLElement>, observe?: boolean): BoxModel | null;

interface UseDisclosureProps {
    isOpen?: boolean;
    defaultIsOpen?: boolean;
    onClose?(): void;
    onOpen?(): void;
    id?: string;
}
declare function useDisclosure(props?: UseDisclosureProps): {
    isOpen: boolean;
    onOpen: () => void;
    onClose: () => void;
    onToggle: () => void;
    isControlled: boolean;
    getButtonProps: (props?: any) => any;
    getDisclosureProps: (props?: any) => any;
};
declare type UseDisclosureReturn = ReturnType<typeof useDisclosure>;

declare type DocumentOrElement = Document | HTMLElement | null;
declare type EventListenerEnv = (() => DocumentOrElement) | DocumentOrElement;
/**
 * React hook to manage browser event listeners
 *
 * @param event the event name
 * @param handler the event handler function to execute
 * @param env the dom environment to execute against (defaults to `document`)
 * @param options the event listener options
 *
 * @internal
 */
declare function useEventListener<K extends keyof DocumentEventMap>(event: K | (string & {}), handler?: (event: DocumentEventMap[K]) => void, env?: EventListenerEnv, options?: boolean | AddEventListenerOptions): () => void;

interface EventListeners {
    add<K extends keyof DocumentEventMap>(el: EventTarget, type: K, listener: (ev: DocumentEventMap[K], info: PointerEventInfo) => any, options?: boolean | AddEventListenerOptions): void;
    add(el: EventTarget, type: string, listener: EventListenerWithPointInfo, options?: boolean | AddEventListenerOptions): void;
    remove<K extends keyof DocumentEventMap>(el: EventTarget, type: K, listener: (ev: DocumentEventMap[K], info: PointerEventInfo) => any, options?: boolean | EventListenerOptions): void;
    remove(el: EventTarget, type: string, listener: EventListenerWithPointInfo, options?: boolean | EventListenerOptions): void;
}
declare function useEventListenerMap(): EventListeners;

declare type UseFocusEffectOptions = {
    shouldFocus: boolean;
    preventScroll?: boolean;
};
/**
 * React hook to focus an element conditionally
 *
 * @param ref the ref of the element to focus
 * @param options focus management options
 */
declare function useFocusEffect<T extends HTMLElement>(ref: React.RefObject<T>, options: UseFocusEffectOptions): void;

interface UseFocusOnHideOptions {
    focusRef: RefObject<FocusableElement>;
    shouldFocus?: boolean;
    visible?: boolean;
}
/**
 * Popover hook to manage the focus when the popover closes or hides.
 *
 * We either want to return focus back to the popover trigger or
 * let focus proceed normally if user moved to another interactive
 * element in the viewport.
 */
declare function useFocusOnHide(containerRef: RefObject<HTMLElement>, options: UseFocusOnHideOptions): void;

interface UseFocusOnMouseDownProps {
    enabled?: boolean;
    ref: React.RefObject<HTMLElement>;
    elements?: Array<React.RefObject<HTMLElement> | HTMLElement | null>;
}
/**
 * Polyfill to get `relatedTarget` working correctly consistently
 * across all browsers.
 *
 * It ensures that elements receives focus on pointer down if
 * it's not the active element.
 *
 * @internal
 */
declare function useFocusOnPointerDown(props: UseFocusOnMouseDownProps): void;

interface UseFocusOnShowOptions {
    visible?: boolean;
    shouldFocus?: boolean;
    preventScroll?: boolean;
    focusRef?: React.RefObject<FocusableElement>;
}
declare function useFocusOnShow<T extends HTMLElement>(target: React.RefObject<T> | T, options?: UseFocusOnShowOptions): void;

declare function useForceUpdate(): () => void;

declare function useId(idProp?: string, prefix?: string): string;
/**
 * React hook to generate ids for use in compound components
 *
 * @param idProp the external id passed from the user
 * @param prefixes array of prefixes to use
 *
 * @example
 *
 * ```js
 * const [buttonId, menuId] = useIds("52", "button", "menu")
 *
 * // buttonId will be `button-52`
 * // menuId will be `menu-52`
 * ```
 */
declare function useIds(idProp?: string, ...prefixes: string[]): string[];
/**
 * Used to generate an id, and after render, check if that id is rendered, so we know
 * if we can use it in places such as `aria-labelledby`.
 *
 * @param partId - The unique id for the component part
 *
 * @example
 * const { ref, id } = useOptionalPart<HTMLInputElement>(`${id}-label`)
 */
declare function useOptionalPart<T = any>(partId: string): {
    ref: (node: T) => void;
    id: string | null;
    isRendered: boolean;
};

/**
 * React Hook that provides a declarative `setInterval`
 *
 * @param callback the callback to execute at interval
 * @param delay the `setInterval` delay (in ms)
 */
declare function useInterval(callback: () => void, delay: number | null): void;

/**
 * React hook to persist any value between renders,
 * but keeps it up-to-date if it changes.
 *
 * @param value the value or function to persist
 */
declare function useLatestRef<T>(value: T): react.MutableRefObject<T>;

declare type ReactRef<T> = React.Ref<T> | React.MutableRefObject<T>;
declare function assignRef<T = any>(ref: ReactRef<T> | undefined, value: T): void;
/**
 * React hook that merges react refs into a single memoized function
 *
 * @example
 * import React from "react";
 * import { useMergeRefs } from `@chakra-ui/hooks`;
 *
 * const Component = React.forwardRef((props, ref) => {
 *   const internalRef = React.useRef();
 *   return <div {...props} ref={useMergeRefs(internalRef, ref)} />;
 * });
 *
 * @see Docs https://chakra-ui.com/docs/hooks/use-merge-refs
 */
declare function useMergeRefs<T>(...refs: (ReactRef<T> | undefined)[]): ((node: T) => void) | null;

declare function useMouseDownRef(shouldListen?: boolean): react.RefObject<HTMLElement>;

interface UseOutsideClickProps {
    /**
     * Whether the hook is enabled
     */
    enabled?: boolean;
    /**
     * The reference to a DOM element.
     */
    ref: React.RefObject<HTMLElement>;
    /**
     * Function invoked when a click is triggered outside the referenced element.
     */
    handler?: (e: Event) => void;
}
/**
 * Example, used in components like Dialogs and Popovers, so they can close
 * when a user clicks outside them.
 *
 * @see Docs https://chakra-ui.com/docs/hooks/use-outside-click
 */
declare function useOutsideClick(props: UseOutsideClickProps): void;

interface UsePanGestureProps {
    onPan?: PanEventHandler;
    onPanStart?: PanEventHandler;
    onPanEnd?: PanEventHandler;
    onPanSessionStart?: PanEventHandler;
    onPanSessionEnd?: PanEventHandler;
    threshold?: number;
}
declare function usePanGesture(ref: React.RefObject<HTMLElement>, props: UsePanGestureProps): void;

/**
 * Credit goes to `framer-motion` of this useful utilities.
 * License can be found here: https://github.com/framer/motion
 */

/**
 * @internal
 */
declare function usePointerEvent(env: EventListenerEnv, eventName: string, handler: EventListenerWithPointInfo, options?: AddEventListenerOptions): () => void;

declare function usePrevious<T>(value: T): T;

declare const useSafeLayoutEffect: typeof useLayoutEffect;

interface UseShortcutProps {
    timeout?: number;
    preventDefault?: (event: React.KeyboardEvent) => boolean;
}
/**
 * React hook that provides an enhanced keydown handler,
 * that's used for key navigation within menus, select dropdowns.
 */
declare function useShortcut(props?: UseShortcutProps): (fn: (keysSoFar: string) => void) => (event: React.KeyboardEvent) => void;

/**
 * React hook that provides a declarative `setTimeout`
 *
 * @param callback the callback to run after specified delay
 * @param delay the delay (in ms)
 */
declare function useTimeout(callback: (...args: any[]) => void, delay: number | null): void;

declare function useUnmountEffect(fn: () => void, deps?: any[]): void;

/**
 * React effect hook that invokes only on update.
 * It doesn't invoke on mount
 */
declare const useUpdateEffect: typeof useEffect;

declare function useWhyDidYouUpdate(name: string, props: any): void;

export { EventListenerEnv, UseAnimationStateProps, UseClipboardOptions, UseControllableStateProps, UseDisclosureProps, UseDisclosureReturn, UseFocusEffectOptions, UseFocusOnHideOptions, UseFocusOnMouseDownProps, UseFocusOnShowOptions, UseOutsideClickProps, UsePanGestureProps, UseShortcutProps, assignRef, useAnimationState, useBoolean, useCallbackRef, useClipboard, useConst, useControllableProp, useControllableState, useDimensions, useDisclosure, useEventListener, useEventListenerMap, useFocusEffect, useFocusOnHide, useFocusOnPointerDown, useFocusOnShow, useForceUpdate, useId, useIds, useInterval, useLatestRef, useMergeRefs, useMouseDownRef, useOptionalPart, useOutsideClick, usePanGesture, usePointerEvent, usePrevious, useSafeLayoutEffect, useShortcut, useTimeout, useUnmountEffect, useUpdateEffect, useWhyDidYouUpdate };
