export * from 'css-box-model';
export { default as mergeWith } from 'lodash.mergewith';

declare function getFirstItem<T>(array: T[]): T | undefined;
declare function getLastItem<T>(array: T[]): T | undefined;
declare function getPrevItem<T>(index: number, array: T[], loop?: boolean): T;
declare function getNextItem<T>(index: number, array: T[], loop?: boolean): T;
declare function removeIndex<T>(array: T[], index: number): T[];
declare function addItem<T>(array: T[], item: T): T[];
declare function removeItem<T>(array: T[], item: T): T[];
/**
 * Get the next index based on the current index and step.
 *
 * @param currentIndex the current index
 * @param length the total length or count of items
 * @param step the number of steps
 * @param loop whether to circle back once `currentIndex` is at the start/end
 */
declare function getNextIndex(currentIndex: number, length: number, step?: number, loop?: boolean): number;
/**
 * Gets the previous index based on the current index.
 * Mostly used for keyboard navigation.
 *
 * @param index - the current index
 * @param count - the length or total count of items in the array
 * @param loop - whether we should circle back to the
 * first/last once `currentIndex` is at the start/end
 */
declare function getPrevIndex(index: number, count: number, loop?: boolean): number;
/**
 * Converts an array into smaller chunks or groups.
 *
 * @param array the array to chunk into group
 * @param size the length of each chunk
 */
declare function chunk<T>(array: T[], size: number): T[][];
/**
 * Gets the next item based on a search string
 *
 * @param items array of items
 * @param searchString the search string
 * @param itemToString resolves an item to string
 * @param currentItem the current selected item
 */
declare function getNextItemFromSearch<T>(items: T[], searchString: string, itemToString: (item: T) => string, currentItem: T): T | undefined;

declare type Merge<T, P> = P & Omit<T, keyof P>;
declare type UnionStringArray<T extends Readonly<string[]>> = T[number];
declare type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;
declare type LiteralUnion<T extends U, U extends any = string> = T | (U & {
    _?: never;
});
declare type AnyFunction<T = any> = (...args: T[]) => any;
declare type FunctionArguments<T extends Function> = T extends (...args: infer R) => any ? R : never;
declare type Dict<T = any> = Record<string, T>;
declare type Booleanish = boolean | "true" | "false";
declare type StringOrNumber = string | number;
declare type EventKeys = "ArrowDown" | "ArrowUp" | "ArrowLeft" | "ArrowRight" | "Enter" | "Space" | "Tab" | "Backspace" | "Control" | "Meta" | "Home" | "End" | "PageDown" | "PageUp" | "Delete" | "Escape" | " " | "Shift";

declare function isNumber(value: any): value is number;
declare function isNotNumber(value: any): boolean;
declare function isNumeric(value: any): boolean;
declare function isArray<T>(value: any): value is Array<T>;
declare function isEmptyArray(value: any): boolean;
declare function isFunction<T extends Function = Function>(value: any): value is T;
declare function isDefined(value: any): boolean;
declare function isUndefined(value: any): value is undefined;
declare function isObject(value: any): value is Dict;
declare function isEmptyObject(value: any): boolean;
declare function isNotEmptyObject(value: any): value is object;
declare function isNull(value: any): value is null;
declare function isString(value: any): value is string;
declare function isCssVar(value: string): boolean;
declare function isEmpty(value: any): boolean;
declare const __DEV__: boolean;
declare const __TEST__: boolean;
declare function isRefObject(val: any): val is {
    current: any;
};
declare function isInputEvent(value: any): value is {
    target: HTMLInputElement;
};

declare function px(value: number | string | null): string | null;
declare function toMediaQueryString(min: string | null, max?: string): string;
declare function analyzeBreakpoints(breakpoints: Dict): {
    keys: Set<string>;
    normalized: string[];
    isResponsive(test: Dict): boolean;
    asObject: Dict<any>;
    asArray: string[];
    details: {
        _minW: string;
        breakpoint: string;
        minW: any;
        maxW: any;
        maxWQuery: string;
        minWQuery: string;
        minMaxQuery: string;
    }[];
    media: (string | null)[];
    /**
     * Converts the object responsive syntax to array syntax
     *
     * @example
     * toArrayValue({ base: 1, sm: 2, md: 3 }) // => [1, 2, 3]
     */
    toArrayValue(test: Dict): any[];
    /**
     * Converts the array responsive syntax to object syntax
     *
     * @example
     * toObjectValue([1, 2, 3]) // => { base: 1, sm: 2, md: 3 }
     */
    toObjectValue(test: any[]): any;
} | null;
declare type AnalyzeBreakpointsReturn = ReturnType<typeof analyzeBreakpoints>;

declare function isElement(el: any): el is Element;
declare function isHTMLElement(el: any): el is HTMLElement;
declare function getOwnerWindow(node?: Element | null): typeof globalThis;
declare function getOwnerDocument(node?: Element | null): Document;
declare function getEventWindow(event: Event): typeof globalThis;
declare function canUseDOM(): boolean;
declare const isBrowser: boolean;
declare const dataAttr: (condition: boolean | undefined) => Booleanish;
declare const ariaAttr: (condition: boolean | undefined) => true | undefined;
declare const cx: (...classNames: any[]) => string;
declare function getActiveElement(node?: HTMLElement): HTMLElement;
declare function contains(parent: HTMLElement | null, child: HTMLElement): boolean;
declare function addDomEvent(target: EventTarget, eventName: string, handler: EventListener, options?: AddEventListenerOptions): () => void;
/**
 * Get the normalized event key across all browsers
 * @param event keyboard event
 */
declare function normalizeEventKey(event: Pick<KeyboardEvent, "key" | "keyCode">): EventKeys;
declare function getRelatedTarget(event: Pick<FocusEvent, "relatedTarget" | "target" | "currentTarget">): HTMLElement;
declare function isRightClick(event: Pick<MouseEvent, "button">): boolean;

declare function getAllFocusable<T extends HTMLElement>(container: T): T[];
declare function getFirstFocusable<T extends HTMLElement>(container: T): T | null;
declare function getAllTabbable<T extends HTMLElement>(container: T, fallbackToFocusable?: boolean): T[];
declare function getFirstTabbableIn<T extends HTMLElement>(container: T, fallbackToFocusable?: boolean): T | null;
declare function getLastTabbableIn<T extends HTMLElement>(container: T, fallbackToFocusable?: boolean): T | null;
declare function getNextTabbable<T extends HTMLElement>(container: T, fallbackToFocusable?: boolean): T | null;
declare function getPreviousTabbable<T extends HTMLElement>(container: T, fallbackToFocusable?: boolean): T | null;
declare function focusNextTabbable<T extends HTMLElement>(container: T, fallbackToFocusable?: boolean): void;
declare function focusPreviousTabbable<T extends HTMLElement>(container: T, fallbackToFocusable?: boolean): void;
declare function closest<T extends HTMLElement>(element: T, selectors: string): Element | null;

declare const hasDisplayNone: (element: HTMLElement) => boolean;
declare const hasTabIndex: (element: HTMLElement) => boolean;
declare const hasNegativeTabIndex: (element: HTMLElement) => boolean;
declare function isDisabled(element: HTMLElement): boolean;
interface FocusableElement {
    focus(options?: FocusOptions): void;
}
declare function isInputElement(element: FocusableElement): element is HTMLInputElement;
declare function isActiveElement(element: FocusableElement): boolean;
declare function hasFocusWithin(element: HTMLElement): boolean;
declare function isHidden(element: HTMLElement): boolean;
declare function isContentEditable(element: HTMLElement): boolean;
declare function isFocusable(element: HTMLElement): boolean;
declare function isTabbable(element?: HTMLElement | null): boolean;

interface ExtendedFocusOptions extends FocusOptions {
    /**
     * Function that determines if the element is the active element
     */
    isActive?: typeof isActiveElement;
    /**
     * If true, the element will be focused in the next tick
     */
    nextTick?: boolean;
    /**
     * If true and element is an input element, the input's text will be selected
     */
    selectTextIfInput?: boolean;
}
declare function focus(element: FocusableElement | null, options?: ExtendedFocusOptions): number;

declare function flatten<Value = any>(target: Record<string, Value> | undefined | null, maxDepth?: number): any;

declare type MaybeFunction<T, Args extends unknown[] = []> = T | ((...args: Args) => T);
declare function runIfFn<T, U>(valueOrFn: T | ((...fnArgs: U[]) => T), ...args: U[]): T;
declare function callAllHandlers<T extends (event: any) => void>(...fns: (T | undefined)[]): (event: FunctionArguments<T>[0]) => void;
declare function callAll<T extends AnyFunction>(...fns: (T | undefined)[]): (arg: FunctionArguments<T>[0]) => void;
declare const compose: <T>(fn1: (...args: T[]) => T, ...fns: ((...args: T[]) => T)[]) => (...args: T[]) => T;
declare function once<T extends AnyFunction>(fn?: T | null): (this: any, ...args: Parameters<T>) => any;
declare const noop: () => void;
declare type MessageOptions = {
    condition: boolean;
    message: string;
};
declare const warn: (this: any, options: MessageOptions) => any;
declare const error: (this: any, options: MessageOptions) => any;
declare const pipe: <R>(...fns: ((a: R) => R)[]) => (v: R) => R;
declare type Point$1 = {
    x: number;
    y: number;
};
declare function distance<P extends Point$1 | number>(a: P, b: P): number;

declare type LazyBehavior = "unmount" | "keepMounted";
interface DetermineLazyBehaviorOptions {
    hasBeenSelected?: boolean;
    isLazy?: boolean;
    isSelected?: boolean;
    lazyBehavior?: LazyBehavior;
}
/**
 * Determines whether the children of a disclosure widget
 * should be rendered or not, depending on the lazy behavior.
 *
 * Used in accordion, tabs, popover, menu and other disclosure
 * widgets.
 */
declare function determineLazyBehavior(options: DetermineLazyBehaviorOptions): boolean;

declare const minSafeInteger: number;
declare const maxSafeInteger: number;
/**
 * Converts a value to a specific precision (or decimal points).
 *
 * Returns a string representing a number in fixed-point notation.
 *
 * @param value the value to convert
 * @param precision the precision or decimal points
 */
declare function toPrecision(value: number, precision?: number): string;
/**
 * Counts the number of decimal places a number has
 *
 * @param value the decimal value to count
 */
declare function countDecimalPlaces(value: number): number;
/**
 * Convert a value to percentage based on lower and upper bound values
 *
 * @param value the value in number
 * @param min the minimum value
 * @param max the maximum value
 */
declare function valueToPercent(value: number, min: number, max: number): number;
/**
 * Calculate the value based on percentage, lower and upper bound values
 *
 * @param percent the percent value in decimals (e.g 0.6, 0.3)
 * @param min the minimum value
 * @param max the maximum value
 */
declare function percentToValue(percent: number, min: number, max: number): number;
/**
 * Rounds a specific value to the next or previous step
 *
 * @param value the value to round
 * @param from the number that stepping started from
 * @param step the specified step
 */
declare function roundValueToStep(value: number, from: number, step: number): string;
/**
 * Clamps a value to ensure it stays within the min and max range.
 *
 * @param value the value to clamp
 * @param min the minimum value
 * @param max the maximum value
 */
declare function clampValue(value: number, min: number, max: number): number;

declare function omit<T extends Dict, K extends keyof T>(object: T, keys: K[]): Omit<T, K>;
declare function pick<T extends Dict, K extends keyof T>(object: T, keys: K[]): { [P in K]: T[P]; };
declare function split<T extends Dict, K extends keyof T>(object: T, keys: K[]): [{ [P in K]: T[P]; }, Omit<T, K>];
/**
 * Get value from a deeply nested object using a string path.
 * Memorizes the value.
 * @param obj - the object
 * @param path - the string path
 * @param fallback  - the fallback value
 */
declare function get(obj: Record<string, any>, path: string | number, fallback?: any, index?: number): any;
declare type Get = (obj: Readonly<object>, path: string | number, fallback?: any, index?: number) => any;
declare const memoize: (fn: Get) => Get;
declare const memoizedGet: Get;
/**
 * Get value from deeply nested object, based on path
 * It returns the path value if not found in object
 *
 * @param path - the string path or value
 * @param scale - the string path or value
 */
declare function getWithDefault(path: any, scale: any): any;
declare type FilterFn<T> = (value: any, key: string, object: T) => boolean;
/**
 * Returns the items of an object that meet the condition specified in a callback function.
 *
 * @param object the object to loop through
 * @param fn The filter function
 */
declare function objectFilter<T extends Dict>(object: T, fn: FilterFn<T>): Dict<any>;
declare const filterUndefined: (object: Dict) => Dict<any>;
declare const objectKeys: <T extends Dict<any>>(obj: T) => (keyof T)[];
/**
 * Object.entries polyfill for Node v10 compatibility
 */
declare const fromEntries: <T extends unknown>(entries: [
    string,
    any
][]) => T;
/**
 * Get the CSS variable ref stored in the theme
 */
declare const getCSSVar: (theme: Dict, scale: string, value: any) => any;

/**
 * Credit goes to `framer-motion` of this useful utilities.
 * License can be found here: https://github.com/framer/motion
 */
declare type AnyPointerEvent = MouseEvent | TouchEvent | PointerEvent;
declare type PointType = "page" | "client";
declare function isMouseEvent(event: AnyPointerEvent): event is MouseEvent;
declare function isTouchEvent(event: AnyPointerEvent): event is TouchEvent;
interface Point {
    x: number;
    y: number;
}
interface PointerEventInfo {
    point: Point;
}
declare type EventHandler = (event: AnyPointerEvent, info: PointerEventInfo) => void;
declare type EventListenerWithPointInfo = (e: AnyPointerEvent, info: PointerEventInfo) => void;
declare function extractEventInfo(event: AnyPointerEvent, pointType?: PointType): PointerEventInfo;
declare function getViewportPointFromEvent(event: AnyPointerEvent): PointerEventInfo;
declare const wrapPointerEventHandler: (handler: EventListenerWithPointInfo, shouldFilterPrimaryPointer?: boolean) => EventListener;
declare function getPointerEventName(name: string): string;
declare function addPointerEvent(target: EventTarget, eventName: string, handler: EventListenerWithPointInfo, options?: AddEventListenerOptions): () => void;
declare function isMultiTouchEvent(event: AnyPointerEvent): boolean;

/**
 * This is a modified version of `PanSession` from `framer-motion`.
 *
 * Credit goes to `framer-motion` of this useful utilities.
 * License can be found here: https://github.com/framer/motion
 */

/**
 * The event information passed to pan event handlers like `onPan`, `onPanStart`.
 *
 * It contains information about the current state of the tap gesture such as its
 * `point`, `delta`, and `offset`
 */
interface PanEventInfo {
    /**
     * Contains `x` and `y` values for the current pan position relative
     * to the device or page.
     */
    point: Point;
    /**
     * Contains `x` and `y` values for the distance moved since
     * the last pan event.
     */
    delta: Point;
    /**
     * Contains `x` and `y` values for the distance moved from
     * the first pan event.
     */
    offset: Point;
    /**
     * Contains `x` and `y` values for the current velocity of the pointer.
     */
    velocity: Point;
}
declare type PanEventHandler = (event: AnyPointerEvent, info: PanEventInfo) => void;
interface PanSessionHandlers {
    /**
     * Callback fired when the pan session is created.
     * This is typically called once `pointerdown` event is fired.
     */
    onSessionStart: PanEventHandler;
    /**
     * Callback fired when the pan session is detached.
     * This is typically called once `pointerup` event is fired.
     */
    onSessionEnd: PanEventHandler;
    /**
     * Callback fired when the pan session has started.
     * The pan session when the pan offset is greater than
     * the threshold (allowable move distance to detect pan)
     */
    onStart: PanEventHandler;
    /**
     * Callback fired while panning
     */
    onMove: PanEventHandler;
    /**
     * Callback fired when the current pan session has ended.
     * This is typically called once `pointerup` event is fired.
     */
    onEnd: PanEventHandler;
}
declare type PanSessionOptions = {
    threshold?: number;
    window?: Window;
};
/**
 * @internal
 *
 * A Pan Session is recognized when the pointer is down
 * and moved in the allowed direction.
 */
declare class PanSession {
    /**
     * We use this to keep track of the `x` and `y` pan session history
     * as the pan event happens. It helps to calculate the `offset` and `delta`
     */
    private history;
    private startEvent;
    private lastEvent;
    private lastEventInfo;
    private handlers;
    private removeListeners;
    /**
     * Minimal pan distance required before recognizing the pan.
     * @default "3px"
     */
    private threshold;
    private win;
    constructor(event: AnyPointerEvent, handlers: Partial<PanSessionHandlers>, threshold?: number);
    private updatePoint;
    private onPointerMove;
    private onPointerUp;
    updateHandlers(handlers: Partial<PanSessionHandlers>): void;
    end(): void;
}

declare const breakpoints: readonly string[];
declare function mapResponsive(prop: any, mapper: (val: any) => any): any;
declare function objectToArrayNotation(obj: Dict, bps?: readonly string[]): any[];
declare function arrayToObjectNotation(values: any[], bps?: readonly string[]): Dict<any>;
declare function isResponsiveObjectLike(obj: Dict, bps?: readonly string[]): boolean;
/**
 * since breakpoints are defined as custom properties on an array, you may
 * `Object.keys(theme.breakpoints)` to retrieve both regular numeric indices
 * and custom breakpoints as string.
 *
 * This function returns true given a custom array property.
 */
declare const isCustomBreakpoint: (maybeBreakpoint: string) => boolean;

declare function getUserAgentBrowser(navigator: Navigator): "Chrome for iOS" | "Edge" | "Silk" | "Chrome" | "Firefox" | "AOSP" | "IE" | "Safari" | "WebKit" | null;
declare type UserAgentBrowser = NonNullable<ReturnType<typeof getUserAgentBrowser>>;
declare function getUserAgentOS(navigator: Navigator): "Android" | "iOS" | "Windows" | "Mac" | "Chrome OS" | "Firefox OS" | null;
declare type UserAgentOS = NonNullable<ReturnType<typeof getUserAgentOS>>;
declare function detectDeviceType(navigator: Navigator): "tablet" | "phone" | "desktop";
declare type UserAgentDeviceType = NonNullable<ReturnType<typeof detectDeviceType>>;
declare function detectOS(os: UserAgentOS): boolean;
declare function detectBrowser(browser: UserAgentBrowser): boolean;
declare function detectTouch(): boolean;

declare type WalkObjectPredicate<Leaf = unknown> = (value: unknown, path: string[]) => Leaf;
declare type MappedLeavesObject<Obj, LeafType> = {
    [Prop in keyof Obj]: Obj[Prop] extends Array<any> ? MappedLeavesObject<Obj[Prop][number], LeafType>[] : Obj[Prop] extends object ? MappedLeavesObject<Obj[Prop], LeafType> : LeafType;
};
declare function walkObject<Target, LeafType>(target: Target, predicate: WalkObjectPredicate<LeafType>): MappedLeavesObject<Target, ReturnType<WalkObjectPredicate<LeafType>>>;

export { AnalyzeBreakpointsReturn, AnyFunction, AnyPointerEvent, Booleanish, Dict, EventHandler, EventKeys, EventListenerWithPointInfo, ExtendedFocusOptions, FocusableElement, FunctionArguments, LazyBehavior, LiteralUnion, MappedLeavesObject, MaybeFunction, Merge, Omit, PanEventHandler, PanEventInfo, PanSession, PanSessionHandlers, PanSessionOptions, Point, PointerEventInfo, StringOrNumber, UnionStringArray, UserAgentBrowser, UserAgentDeviceType, UserAgentOS, WalkObjectPredicate, __DEV__, __TEST__, addDomEvent, addItem, addPointerEvent, analyzeBreakpoints, ariaAttr, arrayToObjectNotation, breakpoints, callAll, callAllHandlers, canUseDOM, chunk, clampValue, closest, compose, contains, countDecimalPlaces, cx, dataAttr, detectBrowser, detectDeviceType, detectOS, detectTouch, determineLazyBehavior, distance, error, extractEventInfo, filterUndefined, flatten, focus, focusNextTabbable, focusPreviousTabbable, fromEntries, get, getActiveElement, getAllFocusable, getAllTabbable, getCSSVar, getEventWindow, getFirstFocusable, getFirstItem, getFirstTabbableIn, getLastItem, getLastTabbableIn, getNextIndex, getNextItem, getNextItemFromSearch, getNextTabbable, getOwnerDocument, getOwnerWindow, getPointerEventName, getPrevIndex, getPrevItem, getPreviousTabbable, getRelatedTarget, getViewportPointFromEvent, getWithDefault, hasDisplayNone, hasFocusWithin, hasNegativeTabIndex, hasTabIndex, isActiveElement, isArray, isBrowser, isContentEditable, isCssVar, isCustomBreakpoint, isDefined, isDisabled, isElement, isEmpty, isEmptyArray, isEmptyObject, isFocusable, isFunction, isHTMLElement, isHidden, isInputElement, isInputEvent, isMouseEvent, isMultiTouchEvent, isNotEmptyObject, isNotNumber, isNull, isNumber, isNumeric, isObject, isRefObject, isResponsiveObjectLike, isRightClick, isString, isTabbable, isTouchEvent, isUndefined, mapResponsive, maxSafeInteger, memoize, memoizedGet, minSafeInteger, noop, normalizeEventKey, objectFilter, objectKeys, objectToArrayNotation, omit, once, percentToValue, pick, pipe, px, removeIndex, removeItem, roundValueToStep, runIfFn, split, toMediaQueryString, toPrecision, valueToPercent, walkObject, warn, wrapPointerEventHandler };
